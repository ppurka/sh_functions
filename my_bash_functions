#!/bin/bash

###   Functions I use frequently  ###

###   Set the colors that will be used 
blue="\x1b[1;34m"
bold="\x1b[1m"
cyan="\x1b[1;36m"
green="\x1b[1;32m"
normal="\x1b[0m"
pink="\x1b[1;35m"
red="\x1b[1;31m"
reverse="\x1b[7m"
underline="\x1b[4m"
yellow="\x1b[1;33m"

# COLORS variable,- contains the colors that will be unset when asked so
COLORS=( blue bold cyan green normal pink red underline yellow )

# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow*$normal ${@}";
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow*$normal ${@} ";
}

# info with carriage return at end
infor() {
    echo -ne "  $yellow*$normal $@$(tput el)\r"
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    local color="$red" msg="ERROR"
    [[ "$1" = "-w" ]] && color="$pink" && msg="WARNING"
    echo -e "  $color*$normal [$color $msg!!$normal ] ${@}" >&2 ;
}

die() {
    Err "$@";
    exit 1;
}

# Usage: centered_output dash|blank "text string"
# where text is less than cols characters in length
centered_output() {
    local cols=$(tput cols)
    local len=${#2}
    if [ $len -ge $cols ]; then
        echo -e "$2"
        return
    fi

    # Create D_ASH and BLANK dynamically according to terminal width
    # Solution got via google:
    # http://www.unix.com/shell-programming-scripting/46584-repeat-character-printf.html#post302150959
    printf -vBLANK "%${cols}s" ""
    local D_ASH="${BLANK// /-}"
    local begin=$(( $cols/2 - $len/2 ));    # Length of dash|blank before text
    local end=$(( $cols - $begin - $len )); # Length of dash|blank after text
    if [ -z "$2" ]; then
        if [ $1 = dash ]; then echo $D_ASH$D_ASH; return;
        else echo; return;
        fi
    fi
    if [ $1 = dash ]; then
        echo -e "${D_ASH:1:$begin}$reverse$2$normal${D_ASH:1:$end}"
    else
        echo -e "${BLANK:1:$begin}$reverse$2$normal${BLANK:1:$end}"
    fi
}

show_osd () {
    if ! which osd_cat >& /dev/null || [[ -z $DISPLAY ]]; then return 1; fi
    osd_cat -a 1 -s 1 -f '-*-helvetica-medium-r-*-*-14-*-*-*-*-*-*-*' \
        -p bottom -A center -c red -d 1 -b percentage -P $1 -T "$2"
    #osd_cat -a 1 -s 1 -f '-*-dejavu sans mono-medium-r-*-*-*-*-*-*-*-*-*-*' \
}

