#!/bin/bash

        #---------------------------------------------------#
        #               Functions I use frequently          #
        #                                   -ppurka         #
        #---------------------------------------------------#

        #--------------------- Changelog -------------------#
        # 07/31/2011:   Add the function show_progress      #
        # 09/25/2009:   Update to make a call to my_dash_fn #
        # 09/19/2009:   Update to include e_remote          #
        # 07/17/2009:   Fixed bug in centered_output        #
        # 05/11/2009:   Added run_loop and support for color#
        #               in centered_output                  #
        # <05/01/2009:  Umpteen number of untracked changes #
        # ??/??/200[78] First version of this script. This  #
        #               is meant to be 'imported' by other  #
        #               bash scripts                        #
        #---------------------------------------------------#

. `which my_dash_functions 2> /dev/null` || \
    echo -e "    \x1b[1;35mWarning!\x1b[0m The script \
\x1b[1;32mmy_dash_functions\x1b[0m was not found in your \$PATH
    Please ensure that the script is available and executable, otherwise
    some functionality may be missing
    "

    
# Set the colors that will be used 
blue="\x1b[1;34m"
bold="\x1b[1m"
cyan="\x1b[1;36m"
green="\x1b[1;32m"
normal="\x1b[0m"
pink="\x1b[1;35m"
red="\x1b[1;31m"
reverse="\x1b[7m"
underline="\x1b[4m"
yellow="\x1b[1;33m"

# COLORS variable,- contains the colors that will be unset when asked so
COLORS=( blue bold cyan green normal pink red underline yellow )

# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow*$normal ${@}"
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow*$normal ${@} "
}

# info with carriage return at end
infor() {
    echo -ne "  $yellow*$normal $@$(tput el)\r"
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    local color="$red" msg="ERROR"
    [[ "$1" = "-w" ]] && color="$pink" && msg="WARNING"
    echo -e "  $color*$normal [$color $msg!!$normal ] ${@/-w/}" >&2
}

die() {
    Err "$@"
    exit 1
}

# Usage: centered_output dash|blank "text string"
# where text is less than cols characters in length
centered_output() {
    local cols=$(tput cols)
    local len="$(echo "$2" | sed -e 's#\\x1[bB]\[[^m]\+m##g')"
    len=${#len}
    if [[ $len -ge $cols ]]; then
        echo -e "$2"
        return
    fi

    # Create D_ASH and BLANK dynamically according to terminal width
    # Solution got via google:
    # http://www.unix.com/shell-programming-scripting/46584-repeat-character-printf.html#post302150959
    printf -vBLANK "%${cols}s" ""
    local D_ASH="${BLANK// /-}"
    local begin=$(( $cols/2 - $len/2 ));    # Length of dash|blank before text
    local end=$(( $cols - $begin - $len )); # Length of dash|blank after text
    if [[ -z "$2" ]]; then
        if [[ $1 = dash ]]; then echo $D_ASH; return
        else echo; return
        fi
    fi
    if [[ $1 = dash ]]; then
        echo -e "${D_ASH:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${D_ASH:1:$end}"
    else
        echo -e "${BLANK:1:$begin}$reverse${2//\\x1[bB]\[0m/\x1b[0m$reverse}\
$normal${BLANK:1:$end}"
    fi
}

# Usage: run_loop <start count> <end count> "text w/ loop var __cnt__ txt"
# __cnt__ will be replaced by the countdown variable
# No checks are made to ensure that $1 and $2 are really integers
run_loop() {
    local clr="$(tput el)"
    if [[ $1 -gt $2 ]]; then
        for (( i=$1; i>=$2; i-- )); do
            infor "${3//__cnt__/$i}$clr"
            sleep 1
        done
    elif [[ $1 -le $2 ]]; then
        for (( i=$1; i<=$2; i++ )); do
            infor "${3//__cnt__/$i}$clr"
            sleep 1
        done
    fi
    echo
}

# Show a progress bar in pure bash
# Usage: echo -e "some text\n$count/$total" | show_progress
#        echo -e "\n\n"
# $total is the max number of items, and $count is the current number
# This function doesn't bother with the length of "some text"
# It assumes that "some text" fits within the window width. If it doesn't
# then it is the responsibility of the parent script.
# The output is of the form
# some text
# █████████████████████------------------               190/  203
show_progress() {
    local -i cols=$(tput cols) progress=0
    local -i lesscols=$(( $cols - 12 ))         # ' xxxxx/xxxxx' at end
    printf -vblank "%${lesscols}s" ""
    local cl="$(tput el)" dash="${blank// /-}" line output
    while read line; do
        if [[ "$output" ]]; then
            # This is the 2nd line of input $count/$total
            echo -e "$output$cl"
            output=""
            progress=$(( $lesscols*${line%/*}/${line#*/} ))
            [[ $progress -eq 0 ]] && progress=1
            echo -ne "$reverse${blank: -${progress}}$normal\
${dash:0:$(( $lesscols - $progress ))} \
$( printf "%5d/%5d" ${line%/*} ${line#*/} )\r"
            tput cuu1
        else
            output="$line"
        fi
    done
}
